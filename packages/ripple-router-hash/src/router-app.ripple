import { effect, untrack, mount, TrackedMap , TrackedArray , track } from 'ripple';
import { getHashPath, findRoute } from '@/lib/utils';
import { NotFound } from '@/components/not-found.ripple';
import { Loading } from '@/components/loading.ripple';
import { Route } from './route.ripple';
import { RoutesContext } from './state.ripple';
import { HashRouter } from "./lib/hash-router"

export function createHashRouterApp({ target }) {
	sessionStorage.setItem("loadedRoutes", JSON.stringify([]));
	mount(RouterProvider, {
		target,
	});
}

export component LoadingSpin(props){
	<div class={`loader ${props["class"]}`}> 
	</div>
}

export component RouterProvider(){
	let node;
	let router = track(null);
	let routes = track(null);
	let loading = track(true);
	const newRoute = track(null)
	const state =  track(null);
	const context = RoutesContext.get();

	effect(() => {
		context.set("routes", @routes)
	});
	effect(() => {
		context.set("router", @router)
	});
	effect(() => {
		context.set("state", @newRoute)
	});
	effect(() => {
		context.set("documentTitle", document.title)
	});

	effect(() => {
		@loading = false;
		if(!@routes || !@state) return;
		const foundRoute = @routes.find(r => {
			// console.log(r.path == @state.route, r.path, @state.route)
			return r.path == @state.route
		});
		if(foundRoute) {
			@newRoute = { ...foundRoute,  ...@state}
		}
		else {
			@newRoute = null;
			console.log("Route not found");
			// sessionStorage.setItem("loadedRoutes", undefined);
			sessionStorage.removeItem("loadedRoutes")
		}
		console.group("newRoute");
		console.table(@newRoute);
		console.groupEnd();
	});

	function onRouteChange(newState) {
		console.group("onRouteChange");
		console.table(newState);
		console.groupEnd();
		@state = newState;
	}
	
	const appRef = n => {
		node = n;
		console.info('router app mounted.');
		try {
			import('virtual:ripple-routes').then(
				({ default: virtualRoutes }) => {
					virtualRoutes = virtualRoutes.map(r =>( r.path == "" ? {...r, path: "/"} : r));
					const routesPattern = virtualRoutes.map(r =>r.path);
					console.group("App Routes");
					console.table(routesPattern.map(r => ({ "routes": r})), ["routes"])
					console.groupEnd();
					@router = new HashRouter({
						routes: routesPattern,
						onRouteChange,
					});
					@routes = virtualRoutes // new TrackedArray (...routes)
				}
			);
		}
		catch(e) {
			console.error(e);
			@state = null;
		}
		

		return () => {
			@router.destroy();
			node = undefined;
			router = undefined;
			console.info('router app unmounted.');
		};
	};
	
	if (@loading) {
		<div class={`absolute bg-gray-300/20 top-0 left-0 h-screen w-screen flex items-center justify-center select-none`}>
			<LoadingSpin class="" />
		</div>
	}

	if (!@newRoute) {
		<NotFound />
	} else {
		<Route route={@newRoute} />
	}

	<div {ref appRef} class={`app-ref absolute w-0 h-0`}>
		
	</div>
}